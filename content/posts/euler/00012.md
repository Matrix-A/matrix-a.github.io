---
title: "第12题: 高可整除三角形数"
subtitle: "Problem 12: Highly Divisible Triangular Number"
date: 2023-12-10T01:30:17+08:00
draft: false

description: "欧拉计划第12题：高可整除三角形数"
tags: ["欧拉计划", "第1-99题", "三角形数"]
keywords: ["欧拉计划", "第12题", "三角形数", "高可整除三角形数", "Highly Divisible Triangular Number"]
categories: ["欧拉计划"]
---
## 题目

### 高可整除三角形数

三角形数序列是由自然数相加组成的。所以第 $7$ 个三角形数是 $1+2+3+4+5+6+7=28$。三角形数的前十项如下：

$$
1,3,6,10,15,21,28,36,45,55,...
$$

让我们列出前七个三角形数的因数：

$$
\begin{aligned}
1&:1 \\\\
3&:1,3 \\\\
6&:1,2,3,6 \\\\
10&:1,2,5,10 \\\\
15&:1,3,5,15 \\\\
21&:1,3,7,21 \\\\
28&:1,2,4,7,14,28
\end{aligned}
$$

我们可以看到 $28$ 是第一个拥有超过 $5$ 个因数的三角形数。

第一个因数个数超过 $500$ 的三角形数的值是多少？

### Highly Divisible Triangular Number

The sequence of triangle numbers is generated by adding the natural numbers. So the $7$th triangle number would be $1+2+3+4+5+6+7=28$. The first ten terms would be: 

$$
1,3,6,10,15,21,28,36,45,55,...
$$

Let us list the factors of the first seven triangle numbers:

We can see that $28$ is the first triangle number to have over five divisors.

$$
\begin{aligned}
1&:1 \\\\
3&:1,3 \\\\
6&:1,2,3,6 \\\\
10&:1,2,5,10 \\\\
15&:1,3,5,15 \\\\
21&:1,3,7,21 \\\\
28&:1,2,4,7,14,28
\end{aligned}
$$

What is the value of the first triangle number to have over five hundred divisors?

## 解题方法

### 暴力解法

三角形数公式如下：

$$
t=\frac{n\times (n+1)}{2}
$$

递增求解三角形数后，通过循环判断该数因数求得答案。

### 求解公式

根据[算术基本定理](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86)，对于任意的正整数 $N$ 存在唯一分解如下公式所示，其中 $p_i$ 为素数

$$
N={p_1}^{a_1}\times {p_2}^{a_2}\times {p_3}^{a_3}\times \cdots \times{p_n}^{a_n} = \prod_{i=1}^{n}p_{i}^{k_{i}}
$$


根据乘法原理对唯一分解中的因数进行组合，则对于任意正整数 $N$ 的因数个数 $d(N)$ ，存在以下计算方法

$$
d(N)=(a_1 + 1) \times (a_2 + 1) \times (a_3 + 1) \times \cdots \times (a_n + 1)=\prod_{i=1}^{n}\left(a_{i}+1\right)
$$

假设 $N=N_1 \times N_2$，且 $N_1$ 和 $N_2$ 互素，则上述公式存在以下变换

$$
\begin{aligned}
N&=N_1 \times N_2 \\
&=\prod_{i=1}^{n_1}p_{i}^{k_{i}} \times \prod_{j=1}^{n_2}p_{j}^{k_{j}} \\
\end{aligned}
$$

因数个数公式存在以下计算：

$$
\begin{aligned}
d(N)&=\prod_{i=1}^{n_1}\left(a_{i}+1\right) \times \prod_{j=1}^{n_2}\left(a_{j}+1\right) \\
&=d(N_1)\times d(N_2) \\
\end{aligned}
$$

观察三角数公式可知 $n$ 和 $n+1$ 之间互素，因此

$$
d(t) = d(\frac{n*(n+1)}{2}) = \begin{cases}
   d(n)\times d(\frac{n+1}{2}) & \text{if $n$ is even} \\
   d(\frac{n}{2})\times d(n+1) & \text{if $n+1$ is even} \\
\end{cases}
$$

根据公式可以得出如下计算步骤：

$$
\begin{aligned}
d(1) &= d(1)\times d(1) \\
d(3) &= d(1)\times d(3) \\
d(6) &= d(3)\times d(2) \\
d(10) &= d(2)\times d(5) \\
&\dots
\end{aligned}
$$

观察上述计算步骤可知，各步骤计算的部分中间结果可复用上一步骤的部分中间计算结果。

据此即可编写代码求解。

## 参考代码

```cpp

constexpr std::uint64_t get_n(std::uint64_t n) {
    return (n * (n + 1)) / 2;
}

// 工具函数：线性筛生成质数表
std::vector<std::uint64_t> linear_sieve(std::uint64_t limit) {
    std::vector<std::uint64_t> primes{};
    primes.reserve(limit / 10);
    std::vector<bool> is_composite(limit + 1, false);

    for (std::uint64_t i{ 2 }; i <= limit; ++i) {
        if (!is_composite[i]) {
            primes.push_back(i);
        }
        for (const auto& p : primes) {
            std::uint64_t mul{ i * p };
            if (mul > limit) break;
            is_composite[mul] = true;
            if (i % p == 0) break;
        }
    }
    return primes;
}

// 工具函数：计算 n 的因子个数
std::uint64_t count_factors(std::uint64_t n, const std::vector<std::uint64_t>& primes) {
    std::uint64_t count{ 1 };
    for (const auto& p : primes) {
        if (p * p > n) break;
        if (n % p == 0) {
            std::uint64_t exp{ 0 };
            while (n % p == 0) {
                n /= p;
                ++exp;
            }
            count *= (exp + 1);
        }
    }
    if (n > 1) count *= 2;
    return count;
}

std::uint64_t solve(std::uint64_t max_count) {

    std::uint64_t next_expand{ 100000 };
    std::vector<std::uint64_t> primes;
    while (true) {
        primes = linear_sieve(next_expand);
        next_expand = next_expand * 2;

        std::uint64_t n{ 0 };
        std::uint64_t last{ count_factors(1, primes) };
        while (n++, true) {
            std::uint64_t cnt;
            std::uint64_t new_last;
            if (n % 2 == 0) {
                new_last = count_factors(n + 1, primes);
            }
            else {
                new_last = count_factors((n + 1) / 2, primes);
            }
            cnt = last * new_last;
            last = new_last;

            if (cnt >= max_count) {
                return get_n(n);
            }
        }
    }
}
```

<div class="hide">

## 正确答案

{{<admonition success 答案 true>}}

**76576500**

{{</admonition >}}

</div>

# 第8题: 序列中的最大乘积


# 题目

## 序列中的最大乘积

在下面的 $1000$ 位数中，相邻四位数的最大乘积是 $9\ast9\ast8\ast9=5832$。

$$
73167176531330624919225119674426574742355349194934 \\\\
96983520312774506326239578318016984801869478851843 \\\\
85861560789112949495459501737958331952853208805511 \\\\
12540698747158523863050715693290963295227443043557 \\\\
66896648950445244523161731856403098711121722383113 \\\\
62229893423380308135336276614282806444486645238749 \\\\
30358907296290491560440772390713810515859307960866 \\\\
70172427121883998797908792274921901699720888093776 \\\\
65727333001053367881220235421809751254540594752243 \\\\
52584907711670556013604839586446706324415722155397 \\\\
53697817977846174064955149290862569321978468622482 \\\\
83972241375657056057490261407972968652414535100474 \\\\
82166370484403199890008895243450658541227588666881 \\\\
16427171479924442928230863465674813919123162824586 \\\\
17866458359124566529476545682848912883142607690042 \\\\
24219022671055626321111109370544217506941658960408 \\\\
07198403850962455444362981230987879927244284909188 \\\\
84580156166097919133875499200524063689912560717606 \\\\
05886116467109405077541002256983155200055935729725 \\\\
71636269561882670428252483600823257530420752963450 \\\\
$$

从这 $1000$ 位数中，找到相邻的 $13$ 位数的乘积的最大值。

## Largest Product in a Series

The four adjacent digits in the $1000$-digit number that have the greatest product are $9\ast9\ast8\ast9=5832$.

$$
73167176531330624919225119674426574742355349194934 \\\\
\vdots \\\\
71636269561882670428252483600823257530420752963450 \\\\
$$

Find the thirteen adjacent digits in the $1000$-digit number that have the greatest product. What is the value of this product?

# 解题方法

使用滑动窗口算法来解最大乘积。时间复杂度位 $O(N)$。

观察题目可知窗口大小为 $13$ ，每次滑动为 $1$ 位，并且考虑到 $0$ 在乘法运算中的特殊性，每个窗口记录以下两个值：

- 所有非 $0$ 位的乘积
- $0$ 的个数

在窗口滑动时，可以根据上个窗口的记录值、当前窗口左边的数字和窗口结尾的数字求得当前窗口需要记录的值以及所有数字的乘积。


{{<admonition example 详细解释 true>}}

假设第 $n$ 位的数字为 $d_n$ ，则第 $n$ 个滑动窗口的各个数字为：

$$
\\{d_n,d_{n+1},d_{n+2},\dots,d_{n+12}\\}
$$

假设第 $n$ 个滑动窗口的所有数字的乘积为 $P_n$，所有非 $0$ 位的乘积为 $p_{n}$，$0$ 的个数为 $c_n$，则

$$
P_n=\begin{cases}
   p_{n} & c_n = 0 \\\\
   0 & c_n \not = 0 \\\\
\end{cases}
$$

观察数据可知， $p_{n+1}$ ， $c_{n+1}$ 可以使用 $p_n$、$c_n$、$d_n$ 和 $d_{n+13}$ 的值来进行快速计算，如下：

$$
c_{n+1}=\begin{cases}
   c_{n} & d_n = 0 \And d_{n+13} = 0 \\\\
   c_{n}+1 & d_n \not = 0 \And d_{n+13} = 0 \\\\
   c_{n}-1 & d_n = 0 \And d_{n+13} \not = 0 \\\\
   c_{n} & d_n \not = 0 \And d_{n+13} \not = 0 \\\\
\end{cases}
$$
$$
p_{n+1}=\begin{cases}
   p_{n} & d_n = 0 \And d_{n+13} = 0 \\\\
   p_{n} / d_n & d_n \not = 0 \And d_{n+13} = 0 \\\\
   p_{n}\ast d_{n+13} & d_n = 0 \And d_{n+13} \not = 0 \\\\
   p_{n} / d_n \ast d_{n+13} & d_n \not = 0 \And d_{n+13} \not = 0 \\\\
\end{cases}
$$

{{</admonition >}}


# 参考代码

{{<admonition tips 提示 true>}}

代码中使用了 **C++23** 中的 `std::views::slide`

{{</admonition >}}

```cpp
std::int64_t Product() {
    std::int64_t result = -1;
    std::int64_t temp = -1; // 所有非 0 位的乘积
    std::int32_t count = 0; // 0 的个数
    for (auto const& x : Num | std::views::slide(13)) {
        if (temp == -1) { // 计算第一个窗口的值
            temp = 1;
            for (auto const& y : x) {
                temp *= y == '0' ? count++, 1 : y - '0';
            }
            if (count == 0) result = temp;
        }
        else { // 处理当前窗口的最后一个值
            temp *= *x.rbegin() == '0' ? count++, 1 : *x.rbegin() - '0';
            if (temp > result && count == 0) {
                result = temp;
            }
        }
        // 处理当前窗口的第一个值
        if (*x.begin() != '0')
            temp /= *x.begin() - '0';
        else
            count--;
    }
    return result;
}
```

<div class="hide">

# 正确答案

{{<admonition success 答案 true>}}

**23514624000**

{{</admonition >}}

</div>

